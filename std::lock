/******************************************************************************

Welcome to GDB Online.
  GDB online is an online compiler and debugger tool for C, C++, Python, PHP, Ruby, 
  C#, OCaml, VB, Perl, Swift, Prolog, Javascript, Pascal, COBOL, HTML, CSS, JS
  Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>
#include <bits/stdc++.h>

using namespace std;

// In this video we will learn how to avoid deadlocks in cpp programming language:
// std::lock() In C++11 It is used to lock multiple mutex at the same time.

// And the syntax is as follow:
// std::lock(m1, m2, m3, m4);
// 1. All arguments are locked via a sequence of calls to lock(),  try_lock(), or unlock() on each argument.
// 2. Order of locking is not defined (it will try to lock provided mutex in any order and ensure that
//     there is no deadlock).
// 3. It is a blocking call.

// [Example:0] -- No deadlock.
//     Thread 1                    Thread 2
//     std::lock(m1,m2);           std::lock(m1,m2);

// [Example:1] -- No deadlock. 

//     Thread 1                    Thread 2
//     std::lock(m1, m2);          std::lock(m2, m1);

// [Example:2] -- No deadlock. 

//     Thread 1                    Thread 2
//     std::lock(m1, m2, m3, m4);  std::lock(m3, m4);
//                                 std::lock(m1, m2);

// [Example:3] -- Yes, the below can deadlock. 

//     Thread 1                    Thread 2
//     std::lock(m1,m2);           std::lock(m3,m4);
//     std::lock(m3,m4);           std::lock(m1,m2);

mutex m1; 
mutex m2;
void taska()
{
    while(1)
    {
        std::lock(m1, m2);
        cout<<"taska"<<endl;
        m1.unlock();
        m2.unlock();
    }
}

void taskb()
{
    while(1)
    {
        std::lock(m2, m1);
        cout<<"taskb"<<endl;
        m2.unlock();
        m1.unlock();
    }
}

int main()
{
    thread th1(taska);
    thread th2(taskb);
    
    th1.join();
    th2.join();

    return 0;
}
